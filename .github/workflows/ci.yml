name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches: [main]
  workflow_call:
    outputs:
      check-passed:
        description: "Checks passed"
        value: ${{ jobs.check.outputs.status }}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

jobs:
  check:
    name: Check
    if: "!contains(github.event.head_commit.message, '[ci-skip]')"
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "10.0.x"

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@efa25f7f19611383d5b0ccf2d1c8914531636bf9
        with:
          components: clippy
          toolchain: 'stable'

      - name: Restore Rust Cargo Cache
        id: cache-rust-cargo
        uses: actions/cache/restore@v5
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            native/target/
          key: ubuntu-24.04-cargo-${{ hashFiles('native/Cargo.toml') }}-${{ github.run_id }}
          restore-keys: |
            ubuntu-24.04-cargo-${{ hashFiles('native/Cargo.toml') }}
        continue-on-error: true

      - name: Setup Protoc
        uses: arduino/setup-protoc@v3

      - name: Run Build
        run: dotnet build -c Release

      - name: Run Test
        run: dotnet test --no-build -c Release -v n --logger 'console;verbosity=normal'
        timeout-minutes: 5

      - name: Run Rust Cargo Clippy
        working-directory: native
        run: cargo clippy --release --all-targets --no-deps -- -D clippy::pedantic
      
      - name: Save Rust Cargo Cache
        uses: actions/cache/save@v5
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            native/target/
          key: ubuntu-24.04-cargo-${{ hashFiles('native/Cargo.toml') }}-${{ github.run_id }}
        continue-on-error: true

  sonar:
    name: SonarCloud
    needs: check
    if: |
      github.event_name == 'push' ||
      (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "10.0.x"

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@efa25f7f19611383d5b0ccf2d1c8914531636bf9
        with:
          components: clippy
          toolchain: 'stable'

      - name: Setup JDK 17
        uses: actions/setup-java@v5
        with:
          java-version: 17
          distribution: 'zulu'

      - name: Restore Rust Cargo Cache
        id: cache-rust-cargo
        uses: actions/cache/restore@v5
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            native/target/
          key: ubuntu-24.04-cargo-${{ hashFiles('native/Cargo.toml') }}-${{ github.run_id }}
          fail-on-cache-miss: 'true'
        continue-on-error: false

      - name: Setup Protoc
        uses: arduino/setup-protoc@v3

      - name: Install SonarQube Tools
        if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
        shell: bash
        run: |
          dotnet tool install --global dotnet-sonarscanner
          dotnet tool install --global dotnet-coverage

      - name: Build and Analyze
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        shell: bash
        run: |
          dotnet sonarscanner \
            begin \
            /k:"nazarii-piontko_datafusion-sharp" \
            /o:"npiontko" \
            /d:sonar.token="$SONAR_TOKEN" \
            /d:sonar.cs.vscoveragexml.reportsPaths=coverage.xml
          
          # Build the project without building the native library, it should be already built in the check job and cached
          dotnet build -c Release -p:BuildNativeLib=false
          dotnet coverage collect "dotnet test --no-build -c Release" -f xml -o "coverage.xml"
          
          dotnet sonarscanner end /d:sonar.token="$SONAR_TOKEN"
